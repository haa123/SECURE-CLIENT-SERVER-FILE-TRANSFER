import sysimport socketimport randomimport base64from Crypto.Cipher import AESimport osimport binasciiimport selectimport hashlibimport bbsfrom time import timefrom datetime import timedelta"""Description:Client request which consists of the ClientID, and DH parameters being            encrypted with client passwordPre-condition:client_id,p=197221152031991558322935568090317202983,g=2,xa,requiredPostcondition: msg1=client ID+request+p+g+encrypted_gxaModp"""def byte_to_binary(n):    return ''.join(str((n & (1 << i)) and 1) for i in reversed(range(8)))def hex_to_binary(h):    return ''.join(byte_to_binary(ord(b)) for b in binascii.unhexlify(h))def message1(client_id, password, p, g, xa):    # calulate client gxamodp    gxaModp = calculate_exponents(g, xa, p)    # convert password to hexadecimal value    hexa_password = base64.b16encode(password)    #print "hexa_password", hexa_password    #encrypting password and gxaModp. encrypted_gxaModp= hexa_password XOR gxaModp    encrypted_gxaModp = xor_encryption(gxaModp, hexa_password)    # concatenate message1 parameters before sending it to server    msg1 = client_id + "|" + "client request |" + str(p) + "|" + str(g) + "|" + str(encrypted_gxaModp)    print "************ MESSAGE 1 Sent from Client ****************"    print "client ID        :", client_id    print "request          :", "client request "    print "p                :", p    print "g                :", g    print "Xa               :", xa    print "gxaModp          :", gxaModp    print "E(pass,gxaModp)  :", encrypted_gxaModp    print "MESSAGE1         :", msg1    print "******************************************************\n\n"    global clientid    clientid = client_id    return msg1def analyse_message2(msg2, password, p, xa):    #extracting Ciphertext1 and Ciphertext2 from Message2    gxsModp_encrypted, ns_encrypted = [x.strip() for x in msg2.split('|', 1)]    #convert password entered by user to hexadecimal value    hexa_password = base64.b16encode(password)    #retrieve (g^Xs mod p) from Message2, Message2 XOR with password    gxsModp_received_from_server = xor_encryption(gxsModp_encrypted, hexa_password)    #Session key    global keyAS    #calculate (g^Xs mod p)^Xa mod p, KAs    keyAS = calculate_exponents(int(gxsModp_received_from_server), xa, p)    #pad key for AES, make it 16    keyAS = round_key(str(keyAS))    #Create object of AES encryption , specify ECB Mode    aes_obj_msg2 = AES.new(keyAS, AES.MODE_ECB)    #Nonce(Ns) decrypted    ns = aes_obj_msg2.decrypt(ns_encrypted)        #for converting hex to binary    global bin_ns    bin_ns = hex_to_binary(ns)    print "************ MESSAGE 2 Received from Server ****************"    print "g_Xbmodp^pass         :", gxsModp_encrypted    print "Encrypted g_xsmodp    :", gxsModp_encrypted    print "Encrypted Ns          :", ns_encrypted    print "Decrypted Ns          :", ns    print "Decrypted Ns in binary:", bin_ns    print "***********************************************************\n\n"    #Random number, Nonce Na    global na    #initialize seed    seed = None    na = str(bbs.blum_blum_shub(seed))          global bin_na    bin_na = hex_to_binary(na)    #concatenate the nonce Na and Ns    concat_na_ns = ns + na    #Message3(E[Kas, Ns || Na])    encrypted_msg3 = aes_obj_msg2.encrypt(concat_na_ns)    msg3 = clientid + "|" + encrypted_msg3     print "************ MESSAGE 3 Sent from Client ****************"    print "Blum Blum Shub Generated Na       :", na    print "Blum Blum Shub generated binary Na:", bin_na    print "E[Kas, Ns||Na]                    :", encrypted_msg3    print "******************************************************\n\n"    print "**********Successful DH key exchange & authentication**************"        print "*************Proceeding to encrypted file transfer*****************"    return msg3def analyse_message4(msg4):    #Message4 received from Server    na_encrypted = msg4    #Create object of AES encryption , specify ECB Mode    aes_obj_msg4 = AES.new(keyAS, AES.MODE_ECB)    #decrypt the received Na    received_na = aes_obj_msg4.decrypt(na_encrypted)    bin_received_na = hex_to_binary(received_na)    #received_na_1 = binascii.unhexlify(received_na)    print "**************** MESSAGE 4 Received from Server ********************"    print "MESSAGE4                          :", na_encrypted        print "Received Decrypted Na             :", received_na    print "Received Decrypted binary Na      :", bin_received_na    print "Blum Blum Shub Generated binary Na:", bin_na      print "*********************************************************************\n\n"    #Compare Nonce Na values    if received_na == na:        #if same, authentication successful        print "Server Authenticated"    else:        #authentication failed        print "Server Authentication Failed"        return "Server Authentication Failed"#pad key for AES, make it 16bytesdef round_key(key):    #find length of key    key_length = len(key)    #if length less than 16, padding needed    if key_length < 16:        #find difference        diff = 16 - key_length        #add zeroes        key += ('0' * diff)    else:        #return first 16 digits        return key[0:16]# xor operation for encryptiondef xor_encryption(gxaModp, hexa_password):    #get padded values of parameters passed    gxaModp, padded_hexa_password = pad(gxaModp, hexa_password)    #XOR operation performed    gxaModp_cipher = hex(int(str(gxaModp), 16) ^ int(str(padded_hexa_password), 16))    #convert to string    gxaModp_cipher = str(gxaModp_cipher)    #keep only desired value    gxaModp_cipher = gxaModp_cipher.replace('L', '').replace('0x', '')    return gxaModp_cipher    # padding zeros for the xor operationdef pad(value1, value2):     #find the difference in lengths of two values passed    diff = len(str(value1)) - len(str(value2))    #if difference negative,make it a positive number    if diff < 0:        diff *= -1    #if length of value1 is greater, pad value2 to match lengths    if len(str(value1)) >= len(str(value2)):        value2 = value2 + ('0' * diff)    else:        #if length of value2 is greater, pad value1 to match lengths        value1 = value1 + ('0' * diff)    return value1, value2    #calculate exponent value for parameters passeddef calculate_exponents(g, xa, p):        required_exponent = xa    #exponent greater than DH parameter p    if required_exponent >= p:        #Fermat theorem        fermat_value = required_exponent/(p-1)        #value obtained after Fermats theorem        required_exponent = required_exponent - (fermat_value * (p-1))        return pow(g, required_exponent, p)#compute Hash H(M) for the mentioned filedef hash_file(filename):    #Hashlib, SHA1 method used    m = hashlib.sha1()    #open the file for reading    with open(filename, 'rb') as fd:        while True:            #read data from file            chunk = fd.read(4096)            if len(chunk) == 0:                #if length received is zero, stop reading                break            else:                #add the read data to file                m.update(chunk)        #Message Digest MD        return m.hexdigest()    def main(argv):    #Maximum buffer size to hold sent/received data 1024bytes    global buffer_length    buffer_length = 1024    #IP address of client and listening port number entered by user    try:        serverIP, port = argv        print "IP Address :", serverIP        print "Port number :", port    except(ValueError):        print "Specify IP Address and Port Number"        sys.exit()        # Create a socket to connect to server    # SOCK_STREAM:used for TCP connection    start_time = time()    socket_conn_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # Connect to the server    socket_conn_client.connect((serverIP, int(port)))    while True:        #Input ClientID and Password        client_id = raw_input("Enter Username/Client ID: ")        password = raw_input("Enter Password: ")        #Input DH parameters        p = raw_input("Enter p or press return to use default value:")        if not p:            #default value of p            p = 197221152031991558322935568090317202983        else:            p = int(p)        g = raw_input("Enter g or press return to use default value:")        if not g:            #default value of g            g = 2        else:            g = int(g)        #Client secret:random number Xa generated        #xa = random.getrandbits(160) + p        xa = int(raw_input('input XA: ')) + p        #function call for forming Message1        msg1 = message1(client_id, password, p, g, xa)        #Message1 send to Server        socket_conn_client.send(msg1)        #To receive Message2 from Server        msg2 = socket_conn_client.recv(1024)        #if Server sent Invalid Password        if msg2 == "Invalid Password":            #Allow credentials to be entered again            continue        elif msg2 == "Invalid Client ID":            #Allow credentials to be entered again            continue        elif msg2 == "Invalid Password. Max attempts exceeded":            #Do not allow credentials to be entered again, display error message            break        elif msg2 == "Invalid Client ID. Max attempts exceeded":            #Do not allow credentials to be entered again, display error message            break        #parse Message2 received from Server, form Message3        msg3 = analyse_message2(msg2, password, p, xa)        #send Message3 to server        socket_conn_client.send(msg3)        #To receive Message4 from Server        msg4 = socket_conn_client.recv(1024)        #Parse Message4 from Server        status = analyse_message4(msg4)        end_time = time()        #Check if Client is authenticated        start_file_time = time()        if status == "Authentication Failed":            print "Terminating Connection..."            #terminate connection            break        else:            #if authenticated, receive file sent from server            #Create object of AES encryption , specify ECB Mode            aes_obj_for_file = AES.new(keyAS, AES.MODE_ECB)            #ns = aes_obj_msg2.decrypt(ns_encrypted)            #Open file to be written            fd = open("cmpe209-1.txt", 'wb')            while True:                # Receive the file data from server                #if no data received for 2secs, stop receiving and consider it as end of file                ready = select.select([socket_conn_client], [], [], 2)                if ready[0]:                    line = socket_conn_client.recv(1024)                    # Write data to file                    print line                    #decrypt the received encrypted file                    line = aes_obj_for_file.decrypt(line).rstrip(b'\0')                    #write the decrypted line to the file                    fd.write(line)                    print line                else:                    break            fd.close()            end_file_time = time()            #Receive Hash sent from Server in Message5            received_hash_of_file = socket_conn_client.recv(1024)            #Compute Hash of the file received at the Client            file_hash = hash_file("cmpe209-1.txt")            print "************ MESSAGE 5 Received from Server-Hash ******"            print "Received Hash            :", received_hash_of_file            print "Computed Hash            :", str(file_hash)            print "******************************************************\n\n"            #Compare the received and the computed hash            if str(received_hash_of_file) == str(file_hash):                #if same, display message                print "Data Integrity Holds"                print"*******************************************************************************************************"                print"Connection closing...."                print"Estimated time taken for DH key exchange: ", (end_time - start_time)                print"Estimated time take for file transfer and encryption: ", (end_file_time - start_file_time)                print"*******************************************************************************************************\n\n"            else:                #if different, display error message                print "Data Integrity Lost"            break    # Close the socket connection    socket_conn_client.close()if __name__ == '__main__':    main(sys.argv[1:])